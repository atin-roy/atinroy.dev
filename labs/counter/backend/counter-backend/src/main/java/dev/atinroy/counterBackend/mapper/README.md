# Mapper Package - DTO â†” Entity Conversion

## ğŸ”€ What's Here?

Mappers convert between your **internal Entities** and **external DTOs**. They're the bridge between your database model and your API contract.

**Key Principle: Convert at boundaries. Never mix Entities and DTOs in business logic.**

```
Frontend
    â†“
CreateUserRequest (DTO)
    â†“
Controller
    â†“
UserMapper.toUserResponse(User entity) â† YOU ARE HERE
    â†“
UserResponse (DTO)
    â†“
Frontend
```

---

## ğŸ“š Mapper in This Museum

### `UserMapper.java`

```java
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserResponse toUserResponse(User user);
}
```

**What's @Mapper?**

This is **MapStruct**, a compile-time code generator. At startup, Spring generates an implementation:

```java
// Generated by MapStruct at compile time
public class UserMapperImpl implements UserMapper {
    @Override
    public UserResponse toUserResponse(User user) {
        if (user == null) return null;
        
        UserResponse response = new UserResponse();
        response.setUserId(user.getUserId());
        response.setUsername(user.getUsername());
        response.setEmail(user.getEmail());
        response.setCreatedAt(user.getCreatedAt());
        // Notice: password is NOT set! ğŸ”
        return response;
    }
}
```

**Why MapStruct instead of manual?**

| Approach | Speed | Type-Safe | Flexible |
|----------|-------|-----------|----------|
| Manual mapping | Slow âš ï¸ | Yes | Yes |
| MapStruct | Fast âœ… | Yes | Yes |
| Jackson (auto) | Very Fast | No âŒ | No |

MapStruct generates the boring code, so you don't have to write `response.setUserId(user.getUserId())` 50 times.

---

## ğŸ¯ Common Patterns

### Pattern 1: Simple Field Mapping (One-to-One)

```java
@Mapper(componentModel = "spring")
public interface SimpleMapper {
    // User.userId â†’ UserResponse.userId (names match, auto-mapped)
    // User.username â†’ UserResponse.username
    // User.email â†’ UserResponse.email
    UserResponse toUserResponse(User user);
}
```

**Works when:** Entity field names match DTO field names.

### Pattern 2: Excluded Fields

```java
@Mapper(componentModel = "spring")
public interface CustomMapper {
    @Mapping(target = "password", ignore = true)  // Don't map password
    UserResponse toUserResponse(User user);
}
```

Here, we explicitly ignore the `password` field (don't copy it to the response). MapStruct enforces this at compile time.

### Pattern 3: Field Renaming

```java
@Mapper(componentModel = "spring")
public interface RenameMapper {
    @Mapping(source = "userId", target = "id")  // Rename field
    @Mapping(source = "userName", target = "name")
    UserResponse toUserResponse(User user);
}
```

### Pattern 4: Custom Methods

```java
@Mapper(componentModel = "spring")
public interface AdvancedMapper {
    UserResponse toUserResponse(User user);
    
    @AfterMapping
    default void afterMapping(@MappingTarget UserResponse response, User user) {
        // Custom logic after standard mapping
        if (response.getUsername() != null) {
            response.setDisplayName(response.getUsername().toUpperCase());
        }
    }
}
```

---

## ğŸ› ï¸ Why NOT Manual Mapping?

### Manual (âŒ Error-prone):
```java
public UserResponse toUserResponse(User user) {
    UserResponse response = new UserResponse();
    response.setUserId(user.getUserId());
    response.setUsername(user.getUsername());
    response.setEmail(user.getEmail());
    response.setCreatedAt(user.getCreatedAt());
    response.setPassword(user.getPassword());  // âš ï¸ OOPS! Leaked password!
    return response;
}
```

### MapStruct (âœ… Safe):
```java
@Mapper(componentModel = "spring")
public interface UserMapper {
    @Mapping(target = "password", ignore = true)
    UserResponse toUserResponse(User user);
}
```

MapStruct **enforces** that you've thought about every field. Compile error if you forget one!

---

## ğŸ² The Missing Counter Mapping

**Q: Where's `CounterMapper`?**

A: Notice in `ApiController`, we manually map Counter â†’ CounterResponse:

```java
private CounterResponse toCounterResponse(Counter counter) {
    CounterResponse response = new CounterResponse();
    response.setCounterId(counter.getCounterId());
    response.setCounterName(counter.getCounterName());
    response.setCounterValue(counter.getCounterValue());
    return response;
}
```

**Why?** For learning purposes. In production, you'd create a `CounterMapper` interface just like `UserMapper`.

---

## ğŸš€ When You Need Complex Mapping

### Example: Map nested objects

```java
@Mapper(componentModel = "spring")
public interface ComplexMapper {
    
    // User has a List<Counter>
    UserDetailResponse toUserDetail(User user);  // MapStruct auto-maps collections!
    
    CounterDetail toCounterDetail(Counter counter);
}
```

---

## ğŸ¯ Key Takeaways

1. **MapStruct generates mapping code** - fast & type-safe
2. **@Mapper(componentModel = "spring")** - integrates with Spring
3. **@Mapping annotations** - control field mapping
4. **Ignore sensitive fields** - like `password`, `apiKey`, etc.
5. **Use mappers at boundaries** - controller layer
6. **Never leak secrets** - MapStruct enforces this via `ignore = true`

---

## ğŸ“– Next Steps

See how everything comes together in the **Controller** (`controller/README.md`).
